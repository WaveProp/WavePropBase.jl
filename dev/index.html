<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home ¬∑ WavePropBase.jl</title><link rel="canonical" href="https://WaveProp.github.io/WavePropBase.jl/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">WavePropBase.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Utils-module"><span>Utils module</span></a></li><li><a class="tocitem" href="#Geometry-module"><span>Geometry module</span></a></li><li><a class="tocitem" href="#Interpolation-module"><span>Interpolation module</span></a></li><li><a class="tocitem" href="#Integration-module"><span>Integration module</span></a></li><li><a class="tocitem" href="#Mesh-module"><span>Mesh module</span></a></li><li><a class="tocitem" href="#IO-module"><span>IO module</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/WaveProp/WavePropBase.jl/blob/master/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="WavePropBase"><a class="docs-heading-anchor" href="#WavePropBase">WavePropBase</a><a id="WavePropBase-1"></a><a class="docs-heading-anchor-permalink" href="#WavePropBase" title="Permalink"></a></h1><ul><li><a href="#WavePropBase.Geometry"><code>WavePropBase.Geometry</code></a></li><li><a href="#WavePropBase.Integration"><code>WavePropBase.Integration</code></a></li><li><a href="#WavePropBase.Utils"><code>WavePropBase.Utils</code></a></li><li><a href="#WavePropBase.ambient_dimension"><code>WavePropBase.ambient_dimension</code></a></li><li><a href="#WavePropBase.boundary-Tuple{WavePropBase.Geometry.Domain}"><code>WavePropBase.boundary</code></a></li><li><a href="#WavePropBase.boundary"><code>WavePropBase.boundary</code></a></li><li><a href="#WavePropBase.bounding_box"><code>WavePropBase.bounding_box</code></a></li><li><a href="#WavePropBase.center"><code>WavePropBase.center</code></a></li><li><a href="#WavePropBase.depth"><code>WavePropBase.depth</code></a></li><li><a href="#WavePropBase.diameter"><code>WavePropBase.diameter</code></a></li><li><a href="#WavePropBase.dimension"><code>WavePropBase.dimension</code></a></li><li><a href="#WavePropBase.distance-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, WavePropBase.Geometry.HyperRectangle{N, T} where T}} where N"><code>WavePropBase.distance</code></a></li><li><a href="#WavePropBase.distance-Union{Tuple{N}, Tuple{WavePropBase.Geometry.HyperRectangle{N, T} where T, WavePropBase.Geometry.HyperRectangle{N, T} where T}} where N"><code>WavePropBase.distance</code></a></li><li><a href="#WavePropBase.domain"><code>WavePropBase.domain</code></a></li><li><a href="#WavePropBase.entities"><code>WavePropBase.entities</code></a></li><li><a href="#WavePropBase.flip_normal"><code>WavePropBase.flip_normal</code></a></li><li><a href="#WavePropBase.geometric_dimension"><code>WavePropBase.geometric_dimension</code></a></li><li><a href="#WavePropBase.getnodes"><code>WavePropBase.getnodes</code></a></li><li><a href="#WavePropBase.image"><code>WavePropBase.image</code></a></li><li><a href="#WavePropBase.jacobian"><code>WavePropBase.jacobian</code></a></li><li><a href="#WavePropBase.meshgen"><code>WavePropBase.meshgen</code></a></li><li><a href="#WavePropBase.normal"><code>WavePropBase.normal</code></a></li><li><a href="#WavePropBase.parametrization"><code>WavePropBase.parametrization</code></a></li><li><a href="#WavePropBase.radius"><code>WavePropBase.radius</code></a></li><li><a href="#WavePropBase.reference_nodes"><code>WavePropBase.reference_nodes</code></a></li><li><a href="#WavePropBase.return_type"><code>WavePropBase.return_type</code></a></li><li><a href="#WavePropBase.tag"><code>WavePropBase.tag</code></a></li><li><a href="#WavePropBase.Geometry.ENTITIES"><code>WavePropBase.Geometry.ENTITIES</code></a></li><li><a href="#WavePropBase.Geometry.TAGS"><code>WavePropBase.Geometry.TAGS</code></a></li><li><a href="#WavePropBase.Geometry.AbstractEntity"><code>WavePropBase.Geometry.AbstractEntity</code></a></li><li><a href="#WavePropBase.Geometry.AbstractReferenceShape"><code>WavePropBase.Geometry.AbstractReferenceShape</code></a></li><li><a href="#WavePropBase.Geometry.AbstractSplitter"><code>WavePropBase.Geometry.AbstractSplitter</code></a></li><li><a href="#WavePropBase.Geometry.CardinalitySplitter"><code>WavePropBase.Geometry.CardinalitySplitter</code></a></li><li><a href="#WavePropBase.Geometry.ClusterTree"><code>WavePropBase.Geometry.ClusterTree</code></a></li><li><a href="#WavePropBase.Geometry.ClusterTree-Union{Tuple{D}, Tuple{T}, Tuple{N}, Tuple{Array{StaticArrays.SVector{N, T}, 1}, Any}} where {N, T, D}"><code>WavePropBase.Geometry.ClusterTree</code></a></li><li><a href="#WavePropBase.Geometry.Domain"><code>WavePropBase.Geometry.Domain</code></a></li><li><a href="#WavePropBase.Geometry.DyadicSplitter"><code>WavePropBase.Geometry.DyadicSplitter</code></a></li><li><a href="#WavePropBase.Geometry.ElementaryEntity"><code>WavePropBase.Geometry.ElementaryEntity</code></a></li><li><a href="#WavePropBase.Geometry.ElementaryEntity-Tuple{Any, Any}"><code>WavePropBase.Geometry.ElementaryEntity</code></a></li><li><a href="#WavePropBase.Geometry.GeometricMinimalSplitter"><code>WavePropBase.Geometry.GeometricMinimalSplitter</code></a></li><li><a href="#WavePropBase.Geometry.GeometricSplitter"><code>WavePropBase.Geometry.GeometricSplitter</code></a></li><li><a href="#WavePropBase.Geometry.HyperRectangle"><code>WavePropBase.Geometry.HyperRectangle</code></a></li><li><a href="#WavePropBase.Geometry.PointEntity"><code>WavePropBase.Geometry.PointEntity</code></a></li><li><a href="#WavePropBase.Geometry.PrincipalComponentSplitter"><code>WavePropBase.Geometry.PrincipalComponentSplitter</code></a></li><li><a href="#WavePropBase.Geometry.ReferenceLine"><code>WavePropBase.Geometry.ReferenceLine</code></a></li><li><a href="#WavePropBase.Geometry.ReferencePoint"><code>WavePropBase.Geometry.ReferencePoint</code></a></li><li><a href="#WavePropBase.Geometry.ReferenceSquare"><code>WavePropBase.Geometry.ReferenceSquare</code></a></li><li><a href="#WavePropBase.Geometry.ReferenceTetrahedron"><code>WavePropBase.Geometry.ReferenceTetrahedron</code></a></li><li><a href="#WavePropBase.Geometry.ReferenceTriangle"><code>WavePropBase.Geometry.ReferenceTriangle</code></a></li><li><a href="#WavePropBase.Geometry._binary_split!-Union{Tuple{D}, Tuple{T}, Tuple{N}, Tuple{WavePropBase.Geometry.ClusterTree{N, T, D}, Int64, Number}} where {N, T, D}"><code>WavePropBase.Geometry._binary_split!</code></a></li><li><a href="#WavePropBase.Geometry.assertequaldim-Tuple{WavePropBase.Geometry.Domain, WavePropBase.Geometry.Domain}"><code>WavePropBase.Geometry.assertequaldim</code></a></li><li><a href="#WavePropBase.Geometry.clear_entities!-Tuple{}"><code>WavePropBase.Geometry.clear_entities!</code></a></li><li><a href="#WavePropBase.Geometry.external_boundary-Tuple{WavePropBase.Geometry.Domain}"><code>WavePropBase.Geometry.external_boundary</code></a></li><li><a href="#WavePropBase.Geometry.internal_boundary-Tuple{WavePropBase.Geometry.Domain}"><code>WavePropBase.Geometry.internal_boundary</code></a></li><li><a href="#WavePropBase.Geometry.key-Tuple{WavePropBase.Geometry.AbstractEntity}"><code>WavePropBase.Geometry.key</code></a></li><li><a href="#WavePropBase.Geometry.new_tag-Tuple{Any}"><code>WavePropBase.Geometry.new_tag</code></a></li><li><a href="#WavePropBase.Geometry.should_split-Tuple{Any, Any}"><code>WavePropBase.Geometry.should_split</code></a></li><li><a href="#WavePropBase.Geometry.skeleton-Tuple{WavePropBase.Geometry.Domain}"><code>WavePropBase.Geometry.skeleton</code></a></li><li><a href="#WavePropBase.Geometry.split!-Tuple{Any, Any}"><code>WavePropBase.Geometry.split!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.ambient_dimension" href="#WavePropBase.ambient_dimension"><code>WavePropBase.ambient_dimension</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ambient_dimension(x)</code></pre><p>Dimension of the ambient space where <code>x</code> lives. For geometrical objects this can differ from its <a href="#WavePropBase.geometric_dimension"><code>geometric_dimension</code></a>; for example a triangle in <code>‚Ñù¬≥</code> has ambient dimension <code>3</code> but geometric dimension <code>2</code>, while a curve in <code>‚Ñù¬≥</code> has ambient dimension 3 but geometric dimension 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.boundary" href="#WavePropBase.boundary"><code>WavePropBase.boundary</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">boundary(œâ)</code></pre><p>Return the boundary of <code>œâ</code>. For a mesh element gives the <code>d-1</code> dimensional elements composing its boundary, while for an entity gives the corresponding <code>d-1</code> dimensional entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L58-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.bounding_box" href="#WavePropBase.bounding_box"><code>WavePropBase.bounding_box</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bounding_box(data)</code></pre><p>Create an axis-aligned bounding box containing all of <code>data</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.center" href="#WavePropBase.center"><code>WavePropBase.center</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">center(Œ©)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L87-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.diameter" href="#WavePropBase.diameter"><code>WavePropBase.diameter</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">diameter(Œ©)</code></pre><p>Largest distance between <code>x</code> and <code>y</code> for <code>x,y ‚àà Œ©</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.dimension" href="#WavePropBase.dimension"><code>WavePropBase.dimension</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">dimension(space)</code></pre><p>The length of a basis for <code>space</code>; i.e. the number of linearly independent elements required to span <code>space</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.domain" href="#WavePropBase.domain"><code>WavePropBase.domain</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">domain(f)</code></pre><p>The domain of the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L120-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.entities" href="#WavePropBase.entities"><code>WavePropBase.entities</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">entities(Œ©::Domain)
entities(M::AbstractMesh)</code></pre><p>Return the geometrical entities composing <code>Œ©</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L144-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.flip_normal" href="#WavePropBase.flip_normal"><code>WavePropBase.flip_normal</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">flip_normal(e::AbstractEntity)</code></pre><p>Flip the orientation of the normal vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L200-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.geometric_dimension" href="#WavePropBase.geometric_dimension"><code>WavePropBase.geometric_dimension</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">geometric_dimension(x)
geometric_dimension(Œ©::Domain)</code></pre><p>Number of degrees of freedom necessary to locally represent the geometrical object. For example, lines have geometric dimension of 1 (whether in <code>‚Ñù¬≤</code> or in <code>‚Ñù¬≥</code>), while surfaces have geometric dimension of 2.</p><p>When the argument is a <code>Domain</code>, return the largest geometric dimension encoutered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L27-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.image" href="#WavePropBase.image"><code>WavePropBase.image</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">image(f)</code></pre><p>The image of the function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.jacobian" href="#WavePropBase.jacobian"><code>WavePropBase.jacobian</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">jacobian(f,x)</code></pre><p>Given a (possibly vector-valued) function <code>f : ùêë·µê ‚Üí ùêÖ·µê</code>, return the <code>m √ó n</code> matrix <code>A·µ¢‚±º = ‚àÇf·µ¢/‚àÇxÃÇ‚±º</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L101-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.meshgen" href="#WavePropBase.meshgen"><code>WavePropBase.meshgen</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">meshgen(Œ©::Domain)</code></pre><p>Generate a mesh for <code>Œ©</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L208-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.normal" href="#WavePropBase.normal"><code>WavePropBase.normal</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normal(el,xÃÇ)
normal(jac::SMatrix)</code></pre><p>The unit normal vector at coordinate <code>xÃÇ</code>, guaranteed to be orthogonal to all columns of <code>jacobian(el,x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.parametrization" href="#WavePropBase.parametrization"><code>WavePropBase.parametrization</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">parametrization(el)</code></pre><p>Return the underlying parametrization of <code>el</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.radius" href="#WavePropBase.radius"><code>WavePropBase.radius</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">radius(Œ©)</code></pre><p>Half the <a href="#WavePropBase.diameter"><code>diameter</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L79-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.reference_nodes" href="#WavePropBase.reference_nodes"><code>WavePropBase.reference_nodes</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reference_nodes(::LagrangeElement{D,Np,T})</code></pre><p>Return the reference nodes on <code>D</code> used for the polynomial interpolation. The function values on these nodes completely determines the interpolating polynomial.</p><p>We use the same convention as <code>gmsh</code> for defining the reference nodes and their order (see <a href="https://gmsh.info/doc/texinfo/gmsh.html#Node-ordering">node ordering</a> on <code>gmsh</code> documentation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L161-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.return_type" href="#WavePropBase.return_type"><code>WavePropBase.return_type</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">return_type(f)</code></pre><p>The type returned by the function-like object <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.tag" href="#WavePropBase.tag"><code>WavePropBase.tag</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tag(::AbstractEntity)</code></pre><p>Integer tag commonly used to idetify geometrical entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/interface.jl#L50-L54">source</a></section></article><h2 id="Utils-module"><a class="docs-heading-anchor" href="#Utils-module">Utils module</a><a id="Utils-module-1"></a><a class="docs-heading-anchor-permalink" href="#Utils-module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils" href="#WavePropBase.Utils"><code>WavePropBase.Utils</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">Utils</code></pre><p>Module containing various utility functions for <code>WaveProp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.SType" href="#WavePropBase.Utils.SType"><code>WavePropBase.Utils.SType</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const SType{T} = Union{T,Type{T}}</code></pre><p>Union type of <code>T</code> and its data type <code>Type{T}</code>. Used to simplify methods defined on singleton types where both <code>foo(::T)</code> and <code>foo(::Type{T})</code> are required.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.ComplexPoint2D" href="#WavePropBase.Utils.ComplexPoint2D"><code>WavePropBase.Utils.ComplexPoint2D</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const ComplexPoint2D
const ComplexPoint2D(x1, x2)
const ComplexPoint2D(x::NTuple{2, ComplexF64})</code></pre><p>A complex 2D point, stored in a StaticArray. ComplexPoint2D = SVector{2, ComplexF64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L238-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.ComplexPoint3D" href="#WavePropBase.Utils.ComplexPoint3D"><code>WavePropBase.Utils.ComplexPoint3D</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const ComplexPoint3D
const ComplexPoint3D(x1, x2, x3)
const ComplexPoint3D(x::NTuple{3, ComplexF64})</code></pre><p>A complex 3D point, stored in a StaticArray. ComplexPoint3D = SVector{3, ComplexF64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L228-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.Point1D" href="#WavePropBase.Utils.Point1D"><code>WavePropBase.Utils.Point1D</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Point1D
const Point1D(x1)</code></pre><p>A point in 1D space, stored in a StaticArray. Point1D = SVector{1, Float64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L199-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.Point2D" href="#WavePropBase.Utils.Point2D"><code>WavePropBase.Utils.Point2D</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Point2D
const Point2D(x1, x2)
const Point2D(x::NTuple{2, Float64})</code></pre><p>A point in 2D space, stored in a StaticArray. Point2D = SVector{2, Float64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L208-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.Point3D" href="#WavePropBase.Utils.Point3D"><code>WavePropBase.Utils.Point3D</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Point3D
const Point3D(x1, x2, x3)
const Point3D(x::NTuple{3, Float64})</code></pre><p>A point in 3D space, stored in a StaticArray. Point3D = SVector{3, Float64}.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L218-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.abstractmethod-Tuple{DataType}" href="#WavePropBase.Utils.abstractmethod-Tuple{DataType}"><code>WavePropBase.Utils.abstractmethod</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">abstractmethod</code></pre><p>A method of an <code>abstract type</code> for which concrete subtypes are expected to provide an implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.assert_extension" href="#WavePropBase.Utils.assert_extension"><code>WavePropBase.Utils.assert_extension</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">assert_extension(fname,ext,[msg])</code></pre><p>Check that <code>fname</code> is of extension <code>ext</code>. Print the message <code>msg</code> as an assertion error otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})" href="#WavePropBase.Utils.blockmatrix_to_matrix-Union{Tuple{Matrix{B}}, Tuple{B}} where B&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})"><code>WavePropBase.Utils.blockmatrix_to_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blockmatrix_to_matrix(A::Matrix{B}) where {B&lt;:SMatrix}</code></pre><p>Convert a <code>Matrix{B}</code>, where <code>B&lt;:SMatrix</code>, to the equivalent <code>Matrix{T}</code>, where <code>T = eltype(B)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B&lt;:(StaticArrays.SVector{S, T} where {S, T})" href="#WavePropBase.Utils.blockvector_to_vector-Union{Tuple{Vector{B}}, Tuple{B}} where B&lt;:(StaticArrays.SVector{S, T} where {S, T})"><code>WavePropBase.Utils.blockvector_to_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blockvector_to_vector(A::Vector{B}) where {B&lt;:SVector}</code></pre><p>Convert a <code>Vector{B}</code>, where <code>B&lt;:SVector</code>, to the equivalent <code>Vector{T}</code>, where <code>T = eltype(B)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.cart2pol-Tuple{Any, Any}" href="#WavePropBase.Utils.cart2pol-Tuple{Any, Any}"><code>WavePropBase.Utils.cart2pol</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cart2pol(x,y)</code></pre><p>Map cartesian coordinates <code>x,y</code> to polar coordinates <code>r,Œ∏</code>. The convention followed is that <code>-œÄ ‚â§ Œ∏ ‚â§ œÄ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.cart2sph-Tuple{Any, Any, Any}" href="#WavePropBase.Utils.cart2sph-Tuple{Any, Any, Any}"><code>WavePropBase.Utils.cart2sph</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cart2sph(x,y,z)</code></pre><p>Map cartesian coordinates <code>x,y,z</code> to spherical ones <code>r, Œ∏, œÜ</code> representing the radius, elevation, and azimuthal angle respectively. The convention followed is that <code>0 ‚â§ Œ∏ ‚â§ œÄ</code> and <code>-œÄ &lt; œÜ ‚â§ œÄ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L280-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.cross_product_matrix-Tuple{Any}" href="#WavePropBase.Utils.cross_product_matrix-Tuple{Any}"><code>WavePropBase.Utils.cross_product_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cross_product_matrix(v)</code></pre><p>Returns the matrix <code>A·µ•</code> associated with the cross product <code>v √ó œï</code> so that <code>v √ó œï = A·µ•œï</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L330-L335">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.diagonalblockmatrix_to_matrix-Union{Tuple{AbstractVector{B}}, Tuple{B}} where B&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})" href="#WavePropBase.Utils.diagonalblockmatrix_to_matrix-Union{Tuple{AbstractVector{B}}, Tuple{B}} where B&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})"><code>WavePropBase.Utils.diagonalblockmatrix_to_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">diagonalblockmatrix_to_matrix(A::Matrix{B}) where {B&lt;:SMatrix}</code></pre><p>Convert a diagonal block matrix <code>A::AbstractVector{B}</code>, where <code>A</code> is the list of diagonal blocks and <code>B&lt;:SMatrix</code>, to the equivalent <code>SparseMatrixCSC{T}</code>, where <code>T = eltype(B)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.enable_debug-Tuple{}" href="#WavePropBase.Utils.enable_debug-Tuple{}"><code>WavePropBase.Utils.enable_debug</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">enable_debug(mname)</code></pre><p>Activate debugging messages.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.getnodes!-NTuple{4, Any}" href="#WavePropBase.Utils.getnodes!-NTuple{4, Any}"><code>WavePropBase.Utils.getnodes!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getnodes!(filter,nodes,tree,[isterminal=true])</code></pre><p>Like <a href="#WavePropBase.getnodes"><code>getnodes</code></a>, but append valid nodes to <code>nodes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L432-L436">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}" href="#WavePropBase.Utils.matrix_to_blockmatrix-Tuple{Matrix{T} where T, Type{var&quot;#s1&quot;} where var&quot;#s1&quot;&lt;:(StaticArrays.SMatrix{S1, S2, T, L} where {S1, S2, T, L})}"><code>WavePropBase.Utils.matrix_to_blockmatrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matrix_to_blockmatrix(A::Matrix,B)</code></pre><p>Convert a <code>Matrix{T}</code> to a <code>Matrix{B}</code>, where <code>B&lt;:Type{SMatrix}</code>. The element type of <code>B</code> must match that of <code>A</code>, and the size of <code>A</code> must be divisible by the size of <code>B</code> along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.notimplemented-Tuple{}" href="#WavePropBase.Utils.notimplemented-Tuple{}"><code>WavePropBase.Utils.notimplemented</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">notimplemented()</code></pre><p>Things which should probably be implemented at some point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.pol2cart-Tuple{Any, Any}" href="#WavePropBase.Utils.pol2cart-Tuple{Any, Any}"><code>WavePropBase.Utils.pol2cart</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pol2cart(r,Œ∏)</code></pre><p>Map polar coordinates <code>r,Œ∏</code> to cartesian coordinates <code>x,y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.print_threads_info-Tuple{}" href="#WavePropBase.Utils.print_threads_info-Tuple{}"><code>WavePropBase.Utils.print_threads_info</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">print_threads_info()</code></pre><p>Prints in console the total number of threads.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.sort_by_type-Tuple{Any}" href="#WavePropBase.Utils.sort_by_type-Tuple{Any}"><code>WavePropBase.Utils.sort_by_type</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sort_by_type(v)</code></pre><p>Sort the elements of <code>v</code> into vectors <code>vi</code> according to their type. Return a <code>Dict{DataType,Vector}</code> mapping each type to a vector of that type.</p><p><strong>Examples</strong></p><pre><code class="language-julia">v = [1,&quot;a&quot;,3,&quot;b&quot;]
dict = sort_by_type(v)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L256-L267">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.sph2cart-Tuple{Any, Any, Any}" href="#WavePropBase.Utils.sph2cart-Tuple{Any, Any, Any}"><code>WavePropBase.Utils.sph2cart</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sph2cart(x,y,z)</code></pre><p>Map spherical coordinates <code>r,Œ∏,œÜ</code> representing the radius, elevation, and azimuthal angle respectively, to cartesian ones <code>x, y, z</code> .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.svector-Tuple{Any, Any}" href="#WavePropBase.Utils.svector-Tuple{Any, Any}"><code>WavePropBase.Utils.svector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svector(f,n)</code></pre><p>Just like <a href="https://docs.julialang.org/en/v1/base/base/#Base.ntuple"><code>Base.ntuple</code></a>, but convert output to an <code>SVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.vector_to_blockvector-Tuple{Vector{T} where T, Type{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(StaticArrays.SVector{S, T} where {S, T})}" href="#WavePropBase.Utils.vector_to_blockvector-Tuple{Vector{T} where T, Type{var&quot;#s3&quot;} where var&quot;#s3&quot;&lt;:(StaticArrays.SVector{S, T} where {S, T})}"><code>WavePropBase.Utils.vector_to_blockvector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_to_blockvector(A::Vector,B)</code></pre><p>Convert a <code>Vector{T}</code> to a <code>Vector{B}</code>, where <code>B&lt;:Type{SVector}</code>. The element type of <code>B</code> must match that of <code>A</code>, and the size of <code>A</code> must be divisible by the size of <code>B</code> along each dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.depth" href="#WavePropBase.depth"><code>WavePropBase.depth</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">depth(node,acc=0)</code></pre><p>Recursive function to compute the depth of <code>node</code> in a a tree-like structure. Require the method <code>getparent(node)</code> to be implemented. Overload this function if your structure has a more efficient way to compute <code>depth</code> (e.g. if it stores it in a field).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L404-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.getnodes" href="#WavePropBase.getnodes"><code>WavePropBase.getnodes</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getnodes(filter,tree,[isterminal=true])</code></pre><p>Return all the nodes of <code>tree</code> satisfying <code>filter(node)::Bool</code>. If <code>isterminal</code>, do not consider childrens of a node for which <code>filter(block)==true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L420-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Utils.@interface" href="#WavePropBase.Utils.@interface"><code>WavePropBase.Utils.@interface</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@interface f [n=1]</code></pre><p>Declare that the function <code>f</code> is an interface function. The call <code>f(args...)</code> resolves to <code>M.f(args...)</code> where <code>M</code> is parent module of the <code>args[n]</code> object.</p><p>The somewhat contrived example below illustrates how this can be used to have a generic method defined in module <code>A</code> applied to a type defined on module <code>B</code> which is independent of <code>A</code> but which implements the interface function <code>f</code>:</p><pre><code class="language-julia">module A
    using WavePropBase.Utils
    Utils.@interface foo
    # a method which works on any type `x` implementing the `foo` function
    do_work(x) = 2*foo(x)
end

module B
    struct Foo end
    foo(x::Foo) = 1
end

using .A
using .B
foo = B.Foo()
A.do_work(foo)

# output

2</code></pre><p>Note that if in the example above module <code>A</code> implements a generic version of <code>foo</code>, the call <code>A.do_work(foo)</code> would use that method instead based on the dispatch rules.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Utils/Utils.jl#L353-L390">source</a></section></article><h2 id="Geometry-module"><a class="docs-heading-anchor" href="#Geometry-module">Geometry module</a><a id="Geometry-module-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry" href="#WavePropBase.Geometry"><code>WavePropBase.Geometry</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">module Geometry</code></pre><p>Module defining basic geometrical concepts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/Geometry.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ENTITIES" href="#WavePropBase.Geometry.ENTITIES"><code>WavePropBase.Geometry.ENTITIES</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const ENTITIES</code></pre><p>Global dictionary storing the used entity tags (the value) for a given dimension (the key).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L171-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.TAGS" href="#WavePropBase.Geometry.TAGS"><code>WavePropBase.Geometry.TAGS</code></a> ‚Äî <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const TAGS::Dict{Int,Vector{Int}}</code></pre><p>Global dictionary storing the used entity tags (the value) for a given dimension (the key).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.AbstractEntity" href="#WavePropBase.Geometry.AbstractEntity"><code>WavePropBase.Geometry.AbstractEntity</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractEntity</code></pre><p>Entity of geometrical nature. Identifiable throught its <code>(dim,tag)</code> key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.AbstractReferenceShape" href="#WavePropBase.Geometry.AbstractReferenceShape"><code>WavePropBase.Geometry.AbstractReferenceShape</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractReferenceShape{N}</code></pre><p>A reference domain/shape in <code>‚Ñú·¥∫</code>.</p><p>Used mostly for defining more complex shapes as transformations mapping an <code>AbstractReferenceShape</code> into some region of <code>‚Ñú·¥π</code>.</p><p>See e.g. <a href="#WavePropBase.Geometry.ReferenceLine"><code>ReferenceLine</code></a> or <a href="#WavePropBase.Geometry.ReferenceTriangle"><code>ReferenceTriangle</code></a> for some examples of concrete subtypes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/referenceshapes.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.AbstractSplitter" href="#WavePropBase.Geometry.AbstractSplitter"><code>WavePropBase.Geometry.AbstractSplitter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractSplitter</code></pre><p>An <code>AbstractSplitter</code> is used to split a <a href="#WavePropBase.Geometry.ClusterTree"><code>ClusterTree</code></a>. The interface requires the following methods:</p><ul><li><code>should_split(clt,splitter)</code> : return a <code>Bool</code> determining if the <code>ClusterTree</code> should be further divided</li><li><code>split!(clt,splitter)</code> : perform the splitting of the <code>ClusterTree</code> handling the necessary data sorting.</li></ul><p>See <a href="#WavePropBase.Geometry.GeometricSplitter"><code>GeometricSplitter</code></a> for an example of an implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L90-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.CardinalitySplitter" href="#WavePropBase.Geometry.CardinalitySplitter"><code>WavePropBase.Geometry.CardinalitySplitter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CardinalitySplitter &lt;: AbstractSplitter</code></pre><p>Used to split a <code>ClusterTree</code> along the largest dimension if <code>length(tree)&gt;nmax</code>. The split is performed so the <code>data</code> is evenly distributed amongst all children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L226-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ClusterTree" href="#WavePropBase.Geometry.ClusterTree"><code>WavePropBase.Geometry.ClusterTree</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct ClusterTree{N,T,D}</code></pre><p>Tree structure used to hierarchically sort points in <code>N</code> dimensions.</p><p>Each node in the tree contains a <code>bounding_box</code> enclosing the <code>points</code> with indices <code>loc2glob[loc_idxs]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ClusterTree-Union{Tuple{D}, Tuple{T}, Tuple{N}, Tuple{Array{StaticArrays.SVector{N, T}, 1}, Any}} where {N, T, D}" href="#WavePropBase.Geometry.ClusterTree-Union{Tuple{D}, Tuple{T}, Tuple{N}, Tuple{Array{StaticArrays.SVector{N, T}, 1}, Any}} where {N, T, D}"><code>WavePropBase.Geometry.ClusterTree</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ClusterTree(points,splitter)
ClusterTree{D}(points,splitter)</code></pre><p>Construct a <code>ClusterTree</code> from the  given <code>points</code> using the splitting strategy encoded in <code>splitter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.Domain" href="#WavePropBase.Geometry.Domain"><code>WavePropBase.Geometry.Domain</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Domain</code></pre><p>Represent a physical domain as a union of entities.</p><p><strong>See also: <a href="#WavePropBase.Geometry.AbstractEntity"><code>AbstractEntity</code></a>, <a href="#WavePropBase.Geometry.ElementaryEntity"><code>ElementaryEntity</code></a>.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.DyadicSplitter" href="#WavePropBase.Geometry.DyadicSplitter"><code>WavePropBase.Geometry.DyadicSplitter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DyadicSplitter</code></pre><p>Used to split an <code>N</code> dimensional <code>ClusterTree</code> into <code>2^N</code> children until at most <code>nmax</code> points are contained in node <em>or</em> the depth <code>dmax</code> is reached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L122-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ElementaryEntity" href="#WavePropBase.Geometry.ElementaryEntity"><code>WavePropBase.Geometry.ElementaryEntity</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ElementaryEntity &lt;: AbstractEntity</code></pre><p>The most basic representation of an <a href="#WavePropBase.Geometry.AbstractEntity"><code>AbstractEntity</code></a>.</p><p><strong>Fields:</strong></p><ul><li><code>dim::UInt8</code>: the geometrical dimension of the entity (e.g. line has <code>dim=1</code>, surface has <code>dim=2</code>, etc)</li><li><code>tag::Int64</code>: an integer tag associated to the entity</li><li><code>boundary::Vector{AbstractEntity}</code>: the entities of dimension <code>dim-1</code> forming the entity&#39;s boundary</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ElementaryEntity-Tuple{Any, Any}" href="#WavePropBase.Geometry.ElementaryEntity-Tuple{Any, Any}"><code>WavePropBase.Geometry.ElementaryEntity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ElementaryEntity(dim,tag)</code></pre><p>Construct an <a href="#WavePropBase.Geometry.ElementaryEntity"><code>ElementaryEntity</code></a> with an empty boundary .</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.GeometricMinimalSplitter" href="#WavePropBase.Geometry.GeometricMinimalSplitter"><code>WavePropBase.Geometry.GeometricMinimalSplitter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GeometricMinimalSplitter &lt;: AbstractSplitter</code></pre><p>Like <a href="#WavePropBase.Geometry.GeometricSplitter"><code>GeometricSplitter</code></a>, but shrinks the children&#39;s containters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L170-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.GeometricSplitter" href="#WavePropBase.Geometry.GeometricSplitter"><code>WavePropBase.Geometry.GeometricSplitter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GeometricSplitter &lt;: AbstractSplitter</code></pre><p>Used to split a <code>ClusterTree</code> in half along the largest axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L152-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.HyperRectangle" href="#WavePropBase.Geometry.HyperRectangle"><code>WavePropBase.Geometry.HyperRectangle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct HyperRectangle{N,T}</code></pre><p>Axis-aligned hyperrectangle in <code>N</code> dimensions given by <code>low_corner::SVector{N,T}</code> and <code>high_corner::SVector{N,T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/hyperrectangle.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.PointEntity" href="#WavePropBase.Geometry.PointEntity"><code>WavePropBase.Geometry.PointEntity</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PointEntity{N,T} &lt;: AbstractEntity</code></pre><p>Zero-dimension geometrical entity. As a subtype of [<code>AbstractEntity</code>],(@ref) the <code>(dim,tag)</code> of all created point entities get added to the global <code>ENTITIES</code>. Intended usage is to build higher dimensionsional entities, and <em>not</em> to represent regular points such as grid points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.PrincipalComponentSplitter" href="#WavePropBase.Geometry.PrincipalComponentSplitter"><code>WavePropBase.Geometry.PrincipalComponentSplitter</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PrincipalComponentSplitter &lt;: AbstractSplitter</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L190-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ReferenceLine" href="#WavePropBase.Geometry.ReferenceLine"><code>WavePropBase.Geometry.ReferenceLine</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferenceLine</code></pre><p>Singleton type representing the <code>[0,1]</code> segment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/referenceshapes.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ReferencePoint" href="#WavePropBase.Geometry.ReferencePoint"><code>WavePropBase.Geometry.ReferencePoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferencePoint</code></pre><p>Singleton type representing a reference zero-dimensional entitty (i.e. a point).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/referenceshapes.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ReferenceSquare" href="#WavePropBase.Geometry.ReferenceSquare"><code>WavePropBase.Geometry.ReferenceSquare</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferenceSquare</code></pre><p>Singleton type representing the square with vertices <code>(0,0),(0,1),(1,1),(1,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/referenceshapes.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ReferenceTetrahedron" href="#WavePropBase.Geometry.ReferenceTetrahedron"><code>WavePropBase.Geometry.ReferenceTetrahedron</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferenceTetrahedron</code></pre><p>Singleton type representing the tetrahedron with vertices <code>(0,0,0),(0,0,1),(0,1,0),(1,0,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/referenceshapes.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.ReferenceTriangle" href="#WavePropBase.Geometry.ReferenceTriangle"><code>WavePropBase.Geometry.ReferenceTriangle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ReferenceTriangle</code></pre><p>Singleton type representing the triangle with vertices <code>(0,0),(0,1),(1,0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/referenceshapes.jl#L42-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{WavePropBase.Geometry.AbstractEntity, WavePropBase.Geometry.AbstractEntity}" href="#Base.:==-Tuple{WavePropBase.Geometry.AbstractEntity, WavePropBase.Geometry.AbstractEntity}"><code>Base.:==</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">==(Œ©1::AbstractEntity,Œ©2::AbstractEntity)</code></pre><p>Two entities are considered equal <code>geometric_dimension(Œ©1)==geometric_dimension(Œ©2)</code> and <code>abs(tag(Œ©1))=abs(tag(Œ©2))</code>. For entities of co-dimension one, the sign of <code>tag(Œ©)</code> is used to determine the orientation of the normal vector.</p><p>Notice that this implies <code>dim</code> and <code>tag</code> of an elementary entity should uniquely define it (up to the sign of <code>tag</code>), and therefore global variables like <a href="#WavePropBase.Geometry.TAGS"><code>TAGS</code></a> are needed to make sure newly created <a href="#WavePropBase.Geometry.AbstractEntity"><code>AbstractEntity</code></a> have a new <code>(dim,tag)</code> identifier.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{WavePropBase.Geometry.Domain, WavePropBase.Geometry.Domain}" href="#Base.:==-Tuple{WavePropBase.Geometry.Domain, WavePropBase.Geometry.Domain}"><code>Base.:==</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">===(Œ©1::Domain,Œ©2::Domain)</code></pre><p>Two <code>Domain</code>s are equal if all their entities are equal (regardless of order).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{WavePropBase.Geometry.ElementaryEntity, WavePropBase.Geometry.Domain}" href="#Base.in-Tuple{WavePropBase.Geometry.ElementaryEntity, WavePropBase.Geometry.Domain}"><code>Base.in</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">in(œâ::ElementaryEntity,Œ©::Domain)</code></pre><p>Check whether an <code>ElementaryEntity</code> belongs to a <code>Domain</code> by recursively checking whether it belongs to its boundary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate" href="#Base.iterate"><code>Base.iterate</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iterate(Œ©::Domain)</code></pre><p>Iterating over a domain means iterating over its entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Tuple{WavePropBase.Geometry.Domain, Integer}" href="#Base.keys-Tuple{WavePropBase.Geometry.Domain, Integer}"><code>Base.keys</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return all tags of the elementary entities in the domain <code>Œ©</code> corresponding to the dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L184-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.keys-Union{Tuple{T}, Tuple{WavePropBase.Geometry.Domain, Vector{T}}} where T&lt;:Integer" href="#Base.keys-Union{Tuple{T}, Tuple{WavePropBase.Geometry.Domain, Vector{T}}} where T&lt;:Integer"><code>Base.keys</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return all tags of the elementary entities in the domain <code>Œ©</code> corresponding to the dimensions contained in <code>dims</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L202-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{WavePropBase.Geometry.Domain}" href="#Base.length-Tuple{WavePropBase.Geometry.Domain}"><code>Base.length</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">length(Œ©:::Domain)</code></pre><p>The length of a domain corresponds to the number of elementary entities that make it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.split-Tuple{WavePropBase.Geometry.HyperRectangle, Any, Any}" href="#Base.split-Tuple{WavePropBase.Geometry.HyperRectangle, Any, Any}"><code>Base.split</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">split(rec::HyperRectangle,[axis]::Int,[place])</code></pre><p>Split a hyperrectangle in two along the <code>axis</code> direction at the  position <code>place</code>. Returns a tuple with the two resulting hyperrectangles.</p><p>When no <code>place</code> is given, defaults to splitting in the middle of the axis.</p><p>When no axis and no place is given, defaults to splitting along the largest axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/hyperrectangle.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry._binary_split!-Union{Tuple{D}, Tuple{T}, Tuple{N}, Tuple{WavePropBase.Geometry.ClusterTree{N, T, D}, Int64, Number}} where {N, T, D}" href="#WavePropBase.Geometry._binary_split!-Union{Tuple{D}, Tuple{T}, Tuple{N}, Tuple{WavePropBase.Geometry.ClusterTree{N, T, D}, Int64, Number}} where {N, T, D}"><code>WavePropBase.Geometry._binary_split!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_binary_split!(node::ClusterTree,dir,pos)
_binary_split!(f,node::ClusterTree)</code></pre><p>Split a <code>ClusterTree</code> into two, sorting all points and data in the process.</p><p>Passing a <code>dir</code> and <code>pos</code> arguments splits the <code>bounding_box</code> box of <code>node</code> along direction <code>dir</code> at position <code>pos</code>, then sorts all points into the resulting  left/right nodes.</p><p>If passed a predicate <code>f</code>, each point is sorted according to whether <code>f(x)</code> returns <code>true</code> (point sorted on the left node) or <code>false</code> (point sorted on the right node). At the end a minimal <code>HyperRectangle</code> containing all left/right points is created.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L251-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.assertequaldim-Tuple{WavePropBase.Geometry.Domain, WavePropBase.Geometry.Domain}" href="#WavePropBase.Geometry.assertequaldim-Tuple{WavePropBase.Geometry.Domain, WavePropBase.Geometry.Domain}"><code>WavePropBase.Geometry.assertequaldim</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">assertequaldim(Œ©1::Domain,Œ©2::Domain)</code></pre><p>Check that two domains have same dimension.</p><p>If one of the domain (or both) are empty, the assertion is assumed to be true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L115-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.clear_entities!-Tuple{}" href="#WavePropBase.Geometry.clear_entities!-Tuple{}"><code>WavePropBase.Geometry.clear_entities!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_entities!()</code></pre><p>Empty the global variables used to keep track of the various entities created.</p><p><strong>See also: <a href="#WavePropBase.Geometry.ENTITIES"><code>ENTITIES</code></a>, <a href="#WavePropBase.Geometry.TAGS"><code>TAGS</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L234-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.external_boundary-Tuple{WavePropBase.Geometry.Domain}" href="#WavePropBase.Geometry.external_boundary-Tuple{WavePropBase.Geometry.Domain}"><code>WavePropBase.Geometry.external_boundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return the external boundaries inside a domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.internal_boundary-Tuple{WavePropBase.Geometry.Domain}" href="#WavePropBase.Geometry.internal_boundary-Tuple{WavePropBase.Geometry.Domain}"><code>WavePropBase.Geometry.internal_boundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><p>Return the internal boundaries inside a domain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.key-Tuple{WavePropBase.Geometry.AbstractEntity}" href="#WavePropBase.Geometry.key-Tuple{WavePropBase.Geometry.AbstractEntity}"><code>WavePropBase.Geometry.key</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">key(e::AbstractEntity)</code></pre><p>The <code>(dim,tag)</code> pair used as a key to identify various abstract entities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.new_tag-Tuple{Any}" href="#WavePropBase.Geometry.new_tag-Tuple{Any}"><code>WavePropBase.Geometry.new_tag</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">new_tag(dim)</code></pre><p>Generate a unique tag for an <code>AbstractEntity</code> of dimension <code>dim</code>.</p><p>The implementation consists of adding one to the maximum value of <code>TAGS[dim]</code></p><p><strong>See also: <a href="#WavePropBase.Geometry.TAGS"><code>TAGS</code></a>.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/entities.jl#L188-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.should_split-Tuple{Any, Any}" href="#WavePropBase.Geometry.should_split-Tuple{Any, Any}"><code>WavePropBase.Geometry.should_split</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">should_split(clt::ClusterTree,splitter::AbstractSplitter)</code></pre><p>Determine whether or not a <code>ClusterTree</code> should be further divided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.skeleton-Tuple{WavePropBase.Geometry.Domain}" href="#WavePropBase.Geometry.skeleton-Tuple{WavePropBase.Geometry.Domain}"><code>WavePropBase.Geometry.skeleton</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">skeleton(Œ©::Domain)</code></pre><p>Return all the boundaries of the domain, i.e. the domain&#39;s skeleton.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Geometry.split!-Tuple{Any, Any}" href="#WavePropBase.Geometry.split!-Tuple{Any, Any}"><code>WavePropBase.Geometry.split!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">split!(clt::ClusterTree,splitter::AbstractSplitter)</code></pre><p>Divide <code>clt</code> using the strategy implemented by <code>splitter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/clustertree.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.boundary-Tuple{WavePropBase.Geometry.Domain}" href="#WavePropBase.boundary-Tuple{WavePropBase.Geometry.Domain}"><code>WavePropBase.boundary</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boundary(Œ©)</code></pre><p>Return a domain comprising the external boundary of Œ©.</p><p>See also: <a href="#WavePropBase.Geometry.external_boundary-Tuple{WavePropBase.Geometry.Domain}"><code>external_boundary</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/domain.jl#L155-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.distance-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, WavePropBase.Geometry.HyperRectangle{N, T} where T}} where N" href="#WavePropBase.distance-Union{Tuple{N}, Tuple{StaticArrays.SVector{N, T} where T, WavePropBase.Geometry.HyperRectangle{N, T} where T}} where N"><code>WavePropBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(x::SVector,r::HyperRectangle)</code></pre><p>The (minimal) Euclidean distance between the point <code>x</code> and any point <code>y ‚àà r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/hyperrectangle.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.distance-Union{Tuple{N}, Tuple{WavePropBase.Geometry.HyperRectangle{N, T} where T, WavePropBase.Geometry.HyperRectangle{N, T} where T}} where N" href="#WavePropBase.distance-Union{Tuple{N}, Tuple{WavePropBase.Geometry.HyperRectangle{N, T} where T, WavePropBase.Geometry.HyperRectangle{N, T} where T}} where N"><code>WavePropBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(r1::HyperRectangle,r2::HyperRectangle)</code></pre><p>The (minimal) Euclidean distance between a point <code>x ‚àà r1</code> and <code>y ‚àà r2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Geometry/hyperrectangle.jl#L84-L88">source</a></section></article><h2 id="Interpolation-module"><a class="docs-heading-anchor" href="#Interpolation-module">Interpolation module</a><a id="Interpolation-module-1"></a><a class="docs-heading-anchor-permalink" href="#Interpolation-module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.AbstractElement" href="#WavePropBase.Interpolation.AbstractElement"><code>WavePropBase.Interpolation.AbstractElement</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractElement{D,T}</code></pre><p>Fixed interpolation schemes over the domain <code>D&lt;:AbstractReferenceShape</code>. This means that the basis functions used for the interpolation are knonw from the type. The type parameter <code>T</code> determines the <a href="#WavePropBase.return_type"><code>return_type</code></a> of the interpolant.</p><p>Instances <code>el</code> of <code>AbstractElement</code> are expected to implement:</p><ul><li><code>el(xÃÇ)</code>: evaluate the interpolation scheme at the coordinate <code>xÃÇ ‚àà D</code>.</li><li><code>jacobian(el,xÃÇ)</code> : evaluate the jacobian matrix of the interpolation at the   coordinate <code>x ‚àà D</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For performance reasons, both <code>el(xÃÇ)</code> and <code>jacobian(el,xÃÇ)</code> should take as input a <code>StaticVector</code> and output a static vector or array.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.AbstractPolynomialSpace" href="#WavePropBase.Interpolation.AbstractPolynomialSpace"><code>WavePropBase.Interpolation.AbstractPolynomialSpace</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractPolynomialSpace{D}</code></pre><p>A polynomial space over <code>D</code>. This is a vector space under polynomial addition and scalar multiplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/polynomials.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.LagrangeElement" href="#WavePropBase.Interpolation.LagrangeElement"><code>WavePropBase.Interpolation.LagrangeElement</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LagrangeElement{D,Np,T} &lt;: AbstractElement{D,T}</code></pre><p>Standard element over <code>D &lt;: AbstractReferenceShape</code> commonly used in finite element methods. The underlying polynomial space is <a href="#WavePropBase.Interpolation.Pk"><code>Pk{D,K}</code></a>, and it evaluates to <code>vals::SVector{Np,T}</code> on the <code>reference_nodes</code> of the element.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.LagrangeLine" href="#WavePropBase.Interpolation.LagrangeLine"><code>WavePropBase.Interpolation.LagrangeLine</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangeLine = LagrangeElement{ReferenceLine}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L116-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.LagrangePoint" href="#WavePropBase.Interpolation.LagrangePoint"><code>WavePropBase.Interpolation.LagrangePoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangePoint = LagrangeElement{ReferencePoint}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L106-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.LagrangeSquare" href="#WavePropBase.Interpolation.LagrangeSquare"><code>WavePropBase.Interpolation.LagrangeSquare</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangeSquare = LagrangeElement{ReferenceSquare}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L131-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.LagrangeTetrahedron" href="#WavePropBase.Interpolation.LagrangeTetrahedron"><code>WavePropBase.Interpolation.LagrangeTetrahedron</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangeTetrahedron = LagrangeElement{ReferenceTetrahedron}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L126-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.LagrangeTriangle" href="#WavePropBase.Interpolation.LagrangeTriangle"><code>WavePropBase.Interpolation.LagrangeTriangle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const LagrangeTriangle = LagrangeElement{ReferenceTriangle}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L121-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.Pk" href="#WavePropBase.Interpolation.Pk"><code>WavePropBase.Interpolation.Pk</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Pk{D,K} &lt;: AbstractPolynomialSpace{D}</code></pre><p>The space of all polynomials over <code>D</code> of degree <code>‚â§K</code>.</p><p>When <code>D</code> is a hypercube in <code>d</code> dimensions, the precise definition is <code>Pk{D,K} = span{ùê±·∂ø : max(Œ∏)‚â§ K}</code>; when <code>D</code> is a <code>d</code>-dimensional simplex, the space is <code>Pk{D,K} = span{ùê±·∂ø : sum(Œ∏)‚â§ K}</code>, where <code>Œ∏ ‚àà ùêç·µà</code> is a multi-index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/polynomials.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.Point" href="#WavePropBase.Interpolation.Point"><code>WavePropBase.Interpolation.Point</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">const Point = LagrangePoint</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L111-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.TensorLagInterp" href="#WavePropBase.Interpolation.TensorLagInterp"><code>WavePropBase.Interpolation.TensorLagInterp</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TensorLagInterp{N,Td,T}</code></pre><p>Generic Lagrange interpolation over an <code>N</code>-dimensional tensor grid. The implementation uses a multidimensional generalization of the barycentric formula.</p><p>The main constructor takes an <code>SVector{N,Vector{Td}}</code> containig the <code>N</code> one-dimensional <code>nodes</code> and an <code>Array{N,T}</code> of the function <code>vals</code> at the tensor product grid formed by the one-dimensional <code>nodes</code>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia">nx = 10
ny = 12
x   = [0.5+0.5cos((2k-1)*œÄ/2nx) for k in 1:nx] # Chebyshev nodes
y   = [0.5+0.5cos((2k-1)*œÄ/2ny) for k in 1:ny] # Chebyshev nodes
f   = (x) -&gt; cos(x[1]*x[2])
vals = [f((x,y)) for x in x, y in y]
p   = TensorLagInterp(SVector(x,y),vals)
p((0.1,0.2)) ‚âà f((0.1,0.2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/tensorlaginterp.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.chebnodes-Tuple{Any, Any, Any}" href="#WavePropBase.Interpolation.chebnodes-Tuple{Any, Any, Any}"><code>WavePropBase.Interpolation.chebnodes</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chebnodes(n,a,b)</code></pre><p>Return the <code>n</code> Chebyshev poins of the first kind on the interval <code>[a,b]</code>. If <code>n</code> is known statically, consider passing <code>Val(n)</code> instead for speed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/tensorlaginterp.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.degree-Union{Tuple{Union{Type{WavePropBase.Interpolation.LagrangeElement{D, Np, T} where T}, WavePropBase.Interpolation.LagrangeElement{D, Np, T} where T}}, Tuple{Np}, Tuple{D}} where {D, Np}" href="#WavePropBase.Interpolation.degree-Union{Tuple{Union{Type{WavePropBase.Interpolation.LagrangeElement{D, Np, T} where T}, WavePropBase.Interpolation.LagrangeElement{D, Np, T} where T}}, Tuple{Np}, Tuple{D}} where {D, Np}"><code>WavePropBase.Interpolation.degree</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">degree(el::LagrangeElement)</code></pre><p>The polynomial degree of the element. A <code>LagrangeElement</code> of degree <code>K</code> and domain <code>D</code> belongs to the space <a href="#WavePropBase.Interpolation.Pk"><code>Pk{D,K}</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/element.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.lagrange_basis-Tuple{Any, WavePropBase.Interpolation.AbstractPolynomialSpace}" href="#WavePropBase.Interpolation.lagrange_basis-Tuple{Any, WavePropBase.Interpolation.AbstractPolynomialSpace}"><code>WavePropBase.Interpolation.lagrange_basis</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lagrange_basis(nodes,[sp::AbstractPolynomialSpace])</code></pre><p>Return the set of <code>n</code> polynomials in <code>sp</code> taking the value of <code>1</code> on node <code>i</code> and <code>0</code> on nodes <code>j ‚âÇÃ∏ i</code> for <code>1 ‚â§ i ‚â§ n</code>. For <code>N</code>-dimensional tensor-product nodes represented in the form of an <code>SVector{N,Vector{T}}</code>, the argument <code>sp</code> may be ommited.</p><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>It is assumed that the value of a function on <code>nodes</code> uniquely determine a polynomial in <code>sp</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/polynomials.jl#L86-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Interpolation.monomial_basis" href="#WavePropBase.Interpolation.monomial_basis"><code>WavePropBase.Interpolation.monomial_basis</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monomial_basis(sp::Pk)</code></pre><p>Return an <code>NTuple</code> containing a basis of monomials <code>ùê±·∂ø</code> spanning the polynomial space <a href="#WavePropBase.Interpolation.Pk"><code>Pk</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Interpolation/polynomials.jl#L41-L46">source</a></section></article><h2 id="Integration-module"><a class="docs-heading-anchor" href="#Integration-module">Integration module</a><a id="Integration-module-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration" href="#WavePropBase.Integration"><code>WavePropBase.Integration</code></a> ‚Äî <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia">module Integration</code></pre><p>Methods for integrating over instances of <a href="#WavePropBase.Geometry.AbstractReferenceShape"><code>AbstractReferenceShape</code></a>.</p><p>Besides some standard quadrature rules used in the <code>FEM</code> module, also defines singular integration routines useful for (weakly) singular integrands.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/Integration.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.AbstractQuadratureRule" href="#WavePropBase.Integration.AbstractQuadratureRule"><code>WavePropBase.Integration.AbstractQuadratureRule</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractQuadratureRule{D&lt;:AbstractReferenceShape}</code></pre><p>A quadrature rule for integrating a function over the domain <code>D</code>.</p><p>An instance <code>q</code> of <code>AbstractQuadratureRule{D}</code> is expected to implement the following methods:</p><ul><li><code>q()</code> : return the nodes <code>x</code> and weights <code>w</code> of the quadrature rule on the reference domain <code>D</code>. For performance reasons, the result should depend only on the type of <code>q</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.AbstractQuadratureRule-Tuple{}" href="#WavePropBase.Integration.AbstractQuadratureRule-Tuple{}"><code>WavePropBase.Integration.AbstractQuadratureRule</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(q::AbstractQuadratureRule)()</code></pre><p>Return the quadrature nodes <code>x</code> and weights <code>w</code> on the <code>domain(q)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.AbstractSingularityHandler" href="#WavePropBase.Integration.AbstractSingularityHandler"><code>WavePropBase.Integration.AbstractSingularityHandler</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractSingularityHandler{R}</code></pre><p>Used for handling localized integrand singularities in <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularityhandler.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.Duffy" href="#WavePropBase.Integration.Duffy"><code>WavePropBase.Integration.Duffy</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Duffy &lt;: AbstractSingularityHandler{RefereceTriangle}</code></pre><p>Change of variables mapping the <code>ReferenceSquare</code> to the <code>RefereceTriangle</code> with the property that the jacobian vanishes at the <code>(1,0)</code> vertex of the triangle.</p><p>Useful for integrating functions with a singularity on the <code>(1,0)</code> edge of the reference triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularityhandler.jl#L105-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.Fejer" href="#WavePropBase.Integration.Fejer"><code>WavePropBase.Integration.Fejer</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Fejer{N}</code></pre><p><code>N</code>-point Fejer&#39;s first quadrature rule for integrating a function over <code>[0,1]</code>. Exactly integrates all polynomials of degree <code>‚â§ N-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L118-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.Gauss" href="#WavePropBase.Integration.Gauss"><code>WavePropBase.Integration.Gauss</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Gauss{D,N} &lt;: AbstractQuadratureRule{D}</code></pre><p>Tabulated <code>N</code>-point symmetric Gauss quadrature rule for integration over <code>D</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L187-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.GaussLegendre" href="#WavePropBase.Integration.GaussLegendre"><code>WavePropBase.Integration.GaussLegendre</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GaussLegendre{N}</code></pre><p><code>N</code>-point Gauss-Legendre quadrature rule for integrating a function over <code>[0,1]</code>. Exactly integrates all polynomials of degree <code>‚â§ 2N-1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.GaussLegendre-Tuple{}" href="#WavePropBase.Integration.GaussLegendre-Tuple{}"><code>WavePropBase.Integration.GaussLegendre</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">GaussLegendre(;order)</code></pre><p>Construct a <code>GaussLegendre</code> of the desired order over the <code>[0,1]</code> interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.IMT" href="#WavePropBase.Integration.IMT"><code>WavePropBase.Integration.IMT</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct IMT{A,P} &lt;: AbstractSingularityHandler{ReferenceLine}</code></pre><p>One-dimensional change of variables mapping <code>[0,1] -&gt; [0,1]</code> with the property that all derivatives vanish at the point <code>x=0</code>.</p><p>See <a href="https://www.elsevier.com/books/methods-of-numerical-integration/davis/978-0-12-206360-2">Davis and Rabinowitz</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularityhandler.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.Kress" href="#WavePropBase.Integration.Kress"><code>WavePropBase.Integration.Kress</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Kress{P} &lt;: AbstractSingularityHandler{ReferenceLine}</code></pre><p>Change of variables mapping <code>[0,1]</code> to <code>[0,1]</code> with the property that the first <code>P</code> derivatives of the transformation vanish at <code>x=0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularityhandler.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.KressP" href="#WavePropBase.Integration.KressP"><code>WavePropBase.Integration.KressP</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct KressP{P} &lt;: AbstractSingularityHandler{ReferenceLine}</code></pre><p>Like <a href="#WavePropBase.Integration.Kress"><code>Kress</code></a>, this change of variables maps the interval <code>[0,1]</code> onto itself, but the first <code>P</code> derivatives of the transformation vanish at <strong>both</strong> endpoints.</p><p>This change of variables can be used to <em>periodize</em> integrals in the following sense. Suppose we wish to compute the integral of <code>f(x)</code> from <code>0</code> to <code>1</code> where <code>f is not a</code>1-periodic function. If <code>œï</code> is an object of type <code>KressP</code>, then using it as a change of variables in the integration yields a similar integral from <code>0</code> to <code>1</code> (the interval <code>0‚â§0‚â§1</code> is mappend onto itself), but with integrand given by <code>g(x) = f(œï(x))œï&#39;(x)</code>. Since <code>œï&#39;</code> vanishes (together with <code>P</code> of its derivatives), the function <code>g(x)</code> is now periodic (up to derivatives of order up to <code>P</code>) at the endpoints. Thus quadrature rules designed for periodic functions like the <a href="#WavePropBase.Integration.TrapezoidalP"><code>TrapezoidalP</code></a> can be used to obtain high order convergence of <code>g</code>, which in turn yields a modified quadrature rule when viewed as a quadrature rule for <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularityhandler.jl#L63-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.SingularQuadratureRule" href="#WavePropBase.Integration.SingularQuadratureRule"><code>WavePropBase.Integration.SingularQuadratureRule</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SingularQuadratureRule{D,Q,S} &lt;: AbstractQuadratureRule{D}</code></pre><p>A quadrature rule over <code>D</code> intended to integrate functions which are singular at a known point <code>s ‚àà D</code>.</p><p>A singular quadrature is rule is composed of a <em>regular</em> quadrature rule (e.g. <code>GaussLegendre</code>) and a <a href="#WavePropBase.Integration.AbstractSingularityHandler"><code>AbstractSingularityHandler</code></a> to transform the regular quadrature. The regular quadrature rule generates nodes and weights on the <code>domain(sing_handler)</code>, and those are mapped into an appropriate quadrature over <code>D = range(sing_handler)</code> using the singularity handler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularquadrule.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.TensorProductQuadrature" href="#WavePropBase.Integration.TensorProductQuadrature"><code>WavePropBase.Integration.TensorProductQuadrature</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TensorProductQuadrature{Q}</code></pre><p>A tensor-product of one-dimension quadrature rules. Integrates over <code>[0,1]^d</code>, where <code>d=length(quad)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">qx = Fejer(10)
qy = GaussLegendre(15)
q  = TensorProductQuadrature(qx,qy)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L225-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.TensorProductSingularityHandler" href="#WavePropBase.Integration.TensorProductSingularityHandler"><code>WavePropBase.Integration.TensorProductSingularityHandler</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TensorProductSingularityHandler{S} &lt;: AbstractSingularityHandler{ReferenceSquare}</code></pre><p>A tensor product of two one-dimensional <code>AbstractSingularityHandler</code>s for performing integration over the <code>ReferenceSquare</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularityhandler.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.Trapezoidal" href="#WavePropBase.Integration.Trapezoidal"><code>WavePropBase.Integration.Trapezoidal</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Trapezoidal{N} &lt;: AbstractQuadratureRule{ReferenceLine}</code></pre><p><code>N</code>-point trapezoidal rule for integrating a function over the interval <code>[0,1]</code>.</p><p>For periodic functions over <code>[0,1]</code>, see <a href="#WavePropBase.Integration.TrapezoidalP"><code>TrapezoidalP</code></a>.</p><p><strong>Examples:</strong></p><pre><code class="language-julia">q    = Trapezoidal(10)
f(x) = exp(x)*cos(x)
integrate(f,q)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L62-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.TrapezoidalP" href="#WavePropBase.Integration.TrapezoidalP"><code>WavePropBase.Integration.TrapezoidalP</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct TrapezoidalP{N} &lt;: AbstractQuadratureRule{ReferenceLine}</code></pre><p>Open trapezoidal rule. Useful for periodic functions since it does not duplicate the boundary nodes, void duplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration._get_gauss_qnodes_and_qweights-Union{Tuple{D}, Tuple{Type{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:WavePropBase.Geometry.AbstractReferenceShape{D}, Any}} where D" href="#WavePropBase.Integration._get_gauss_qnodes_and_qweights-Union{Tuple{D}, Tuple{Type{var&quot;#s4&quot;} where var&quot;#s4&quot;&lt;:WavePropBase.Geometry.AbstractReferenceShape{D}, Any}} where D"><code>WavePropBase.Integration._get_gauss_qnodes_and_qweights</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_get_qnodes_and_qweights(R::Type{&lt;:AbstractReferenceShape{D}}, N) where D</code></pre><p>Returns the <code>N</code>-point symmetric gaussian qnodes and qweights <code>(x, w)</code> for integration over <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrulestables.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.integrate-Tuple{Any, WavePropBase.Integration.AbstractQuadratureRule}" href="#WavePropBase.Integration.integrate-Tuple{Any, WavePropBase.Integration.AbstractQuadratureRule}"><code>WavePropBase.Integration.integrate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">integrate(f,q::AbstractQuadrature)
integrate(f,x,w)</code></pre><p>Integrate the function <code>f</code> using the quadrature rule <code>q</code>. This is simply <code>sum(f.(x) .* w)</code>, where <code>x</code> and <code>w</code> are the quadrature nodes and weights, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.qnodes-Tuple{WavePropBase.Integration.AbstractQuadratureRule}" href="#WavePropBase.Integration.qnodes-Tuple{WavePropBase.Integration.AbstractQuadratureRule}"><code>WavePropBase.Integration.qnodes</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qnodes(Y)</code></pre><p>Return the quadrature nodes associated with <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.qrule_for_reference_shape-Tuple{Any, Any}" href="#WavePropBase.Integration.qrule_for_reference_shape-Tuple{Any, Any}"><code>WavePropBase.Integration.qrule_for_reference_shape</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qrule_for_reference_shape(ref,order)</code></pre><p>Given a <code>ref</code>erence shape and a desired quadrature <code>order</code>, return an appropiate quadrature rule.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L276-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.qweights-Tuple{WavePropBase.Integration.AbstractQuadratureRule}" href="#WavePropBase.Integration.qweights-Tuple{WavePropBase.Integration.AbstractQuadratureRule}"><code>WavePropBase.Integration.qweights</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">qweights(Y)</code></pre><p>Return the quadrature weights associated with <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.refine-Union{Tuple{WavePropBase.Integration.GaussLegendre{N}}, Tuple{N}, Tuple{WavePropBase.Integration.GaussLegendre{N}, Any}} where N" href="#WavePropBase.Integration.refine-Union{Tuple{WavePropBase.Integration.GaussLegendre{N}}, Tuple{N}, Tuple{WavePropBase.Integration.GaussLegendre{N}, Any}} where N"><code>WavePropBase.Integration.refine</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">refine(q::AbstractQuadratureRule,[k=2])</code></pre><p>Generate a similar quadrature rule, but with <code>k</code>-times as many quadrature nodes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/quadrule.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.singular_quadrature-Tuple{Any, WavePropBase.Integration.SingularQuadratureRule, Any}" href="#WavePropBase.Integration.singular_quadrature-Tuple{Any, WavePropBase.Integration.SingularQuadratureRule, Any}"><code>WavePropBase.Integration.singular_quadrature</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">singular_quadrature(k,q::SingularQuadratureRule,s)</code></pre><p>Return nodes and weights to integrate a function over <code>domain(q)</code> with a factored weight <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularquadrule.jl#L59-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Integration.singular_weights-Tuple{Any, Any, WavePropBase.Integration.SingularQuadratureRule, Any}" href="#WavePropBase.Integration.singular_weights-Tuple{Any, Any, WavePropBase.Integration.SingularQuadratureRule, Any}"><code>WavePropBase.Integration.singular_weights</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">singular_weights(k,xi,q::SingularQuadratureRule,s)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Integration/singularquadrule.jl#L75-L77">source</a></section></article><h2 id="Mesh-module"><a class="docs-heading-anchor" href="#Mesh-module">Mesh module</a><a id="Mesh-module-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.AbstractMesh" href="#WavePropBase.Mesh.AbstractMesh"><code>WavePropBase.Mesh.AbstractMesh</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractMesh{N,T}</code></pre><p>An abstract mesh structure in dimension <code>N</code> with primite data of type <code>T</code> (e.g. <code>Float64</code> for double precision representation).</p><p>Concrete subtypes of <code>AbstractMesh</code> should implement <a href="#WavePropBase.Mesh.ElementIterator"><code>ElementIterator</code></a> for accessing the mesh elements, and/or <a href="#WavePropBase.Mesh.NodeIterator"><code>NodeIterator</code></a> for accesing the mesh nodes.</p><p><strong>See also: <a href="#WavePropBase.Mesh.GenericMesh"><code>GenericMesh</code></a>, <a href="#WavePropBase.Mesh.UniformCartesianMesh"><code>UniformCartesianMesh</code></a></strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/abstractmesh.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.ElementIterator" href="#WavePropBase.Mesh.ElementIterator"><code>WavePropBase.Mesh.ElementIterator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ElementIterator{E,M}</code></pre><p>Return an iterator for all elements of type <code>E</code> on a mesh of type <code>M</code>.</p><p>Besides the methods listed in the <a href="https://docs.julialang.org/en/v1/manual/interfaces/">iterator iterface</a> of <code>Julia</code>, some functions also require the <code>getindex(iter,i::Int)</code> method for accessing the <code>i</code>-th element directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/abstractmesh.jl#L32-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.GenericMesh" href="#WavePropBase.Mesh.GenericMesh"><code>WavePropBase.Mesh.GenericMesh</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct GenericMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>Data structure representing a generic mesh in an ambient space of dimension <code>N</code>, with data of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/genericmesh.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.NodeIterator" href="#WavePropBase.Mesh.NodeIterator"><code>WavePropBase.Mesh.NodeIterator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NodeIterator{M}</code></pre><p>Iterator for all the nodes in a mesh of type <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/abstractmesh.jl#L62-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.SubMesh" href="#WavePropBase.Mesh.SubMesh"><code>WavePropBase.Mesh.SubMesh</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct SubMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>Create a view of a <code>parent</code> mesh over a given <code>domain</code>.</p><p>A submesh implements the interface for <code>AbstractMesh</code>; therefore you can iterate over elements of the submesh just like you would with a mesh.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/submesh.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.UniformCartesianMesh" href="#WavePropBase.Mesh.UniformCartesianMesh"><code>WavePropBase.Mesh.UniformCartesianMesh</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct UniformCartesianMesh{N,T} &lt;: AbstractMesh{N,T}</code></pre><p>An <code>N</code>-dimensional cartesian grid given as the tensor-product of <code>N</code> one-dimensional <code>LinRange{T}</code> grids.</p><p>Iterating over a <code>UniformCartesianMesh</code> generates the elements which compose the mesh; i.e. the <code>HyperRectangle</code> cells.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/cartesianmesh.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.UniformCartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{WavePropBase.Geometry.HyperRectangle{N, T}, Tuple{Vararg{T, N}} where T}} where {N, T}" href="#WavePropBase.Mesh.UniformCartesianMesh-Union{Tuple{T}, Tuple{N}, Tuple{WavePropBase.Geometry.HyperRectangle{N, T}, Tuple{Vararg{T, N}} where T}} where {N, T}"><code>WavePropBase.Mesh.UniformCartesianMesh</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">UniformCartesianMesh(;domain::HyperRectangle,sz::NTuple)</code></pre><p>Construct a uniform <code>UniformCartesianMesh</code> with <code>sz[d]</code> elements along dimension <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/cartesianmesh.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.decompose-Tuple{WavePropBase.Geometry.ReferenceLine, Float64}" href="#WavePropBase.Mesh.decompose-Tuple{WavePropBase.Geometry.ReferenceLine, Float64}"><code>WavePropBase.Mesh.decompose</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">decompose(s::AbstractReferenceShape,x,[target_shape])</code></pre><p>Decompose an <a href="#WavePropBase.Geometry.AbstractReferenceShape"><code>AbstractReferenceShape</code></a> into <a href="#WavePropBase.Interpolation.LagrangeElement"><code>LagrangeElement</code></a>s so that <code>x</code> is a vertex of the children elements.</p><p><strong>Examples</strong></p><p>s = ReferenceLine() el1, el2 = decompose(s,0.3) el1(1) == el2(0) == 0.3 # true</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/decompose.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.GenericMesh, Any, DataType}" href="#WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.GenericMesh, Any, DataType}"><code>WavePropBase.Mesh.dom2elt</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dom2elt(m::GenericMesh,Œ©,E)</code></pre><p>Compute the element indices <code>idxs</code> of the elements of type <code>E</code> composing <code>Œ©</code>, so that <code>m[E][idxs]</code> gives all the elements of type <code>E</code> meshing <code>Œ©</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/genericmesh.jl#L48-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.GenericMesh, Any}" href="#WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.GenericMesh, Any}"><code>WavePropBase.Mesh.dom2elt</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dom2elt(m::GenericMesh,Œ©)</code></pre><p>Return a <code>Dict</code> with keys being the element types of <code>m</code>, and values being the indices of the elements in <code>Œ©</code> of that type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/genericmesh.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.SubMesh}" href="#WavePropBase.Mesh.dom2elt-Tuple{WavePropBase.Mesh.SubMesh}"><code>WavePropBase.Mesh.dom2elt</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dom2elt(m::SubMesh,[E])</code></pre><p>A dictionary with keys being the element types of <code>m</code>, and values being the element indices in the parent mesh. If a type <code>E</code> is given, return the values associated with that key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/Mesh/submesh.jl#L52-L58">source</a></section></article><h2 id="IO-module"><a class="docs-heading-anchor" href="#IO-module">IO module</a><a id="IO-module-1"></a><a class="docs-heading-anchor-permalink" href="#IO-module" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.IO.PlotPoints" href="#WavePropBase.IO.PlotPoints"><code>WavePropBase.IO.PlotPoints</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PlotPoints</code></pre><p>Structure used for dispatching <code>SVector</code> to plot recipes without type-piracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/IO/plotsIO.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="WavePropBase.IO.PlotTree" href="#WavePropBase.IO.PlotTree"><code>WavePropBase.IO.PlotTree</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PlotTree</code></pre><p>Used to plot entire tree associated with a tree node, instead of just the node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/WaveProp/WavePropBase.jl/blob/497dbcfb5b1603412bd1dbc241247d146003b0d4/src/IO/plotsIO.jl#L128-L132">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 24 July 2021 17:16">Saturday 24 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
